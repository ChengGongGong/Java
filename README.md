# Java
## 1. java内存区域
### 1.运行时数据区域
1. 程序计数器：线程私有，为了线程切换后能恢复到正确的执行位置
2. java虚拟机栈：线程私有，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息
3. 本地方法栈：为虚拟机使用到的本地（Native）方法服务。
4. java堆：各个线程共享的内存区域，存放对象实例，几乎所有的对象实例以及数组都应当在堆上分配。
5. 方法区：各个线程共享的内存区域，存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
6. 直接内存：本机直接内存的分配不会受到Java堆大小的限制
7. 元空间：JDK1.8之前，hotspot虚拟机采用永久代的方法实现方法区，容易遇到内存溢出的问题。JDK 1.8之后废弃永久代，使用本地内存来存储类元数据信息
8. 常量池：字符串常量池、class常量池、运行时常量池 
### 2.对象探索
1. 对象的创建：

    类加载检查->分配内存(指针碰撞、空闲列表)：分配内存动作的线程安全问题-->内存空间初始化为零值--->设置对象头信息-->new关键字执行<init>()方法，按照程序员的意愿对对象进行初始化
2. 对象的内存布局
  
        对象头（Header）：存储对象自身的运行时数据、类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例、如果是数组的话还需记录数组长度；
  
        实例数据（Instance Data）：
  
        对齐填充（Padding）：不是必然存在的，HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，起着占位符的作用
3. 对象的访问定位：使用句柄访问、直接指针访问
### 3. 垃圾收集器
1. 判断对象已死？
  
        1. 引用计数法：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的
            但是很难解决对象之间相互循环引用的问题。

        2. 可达性分析算法：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），
           如果某个对象到GC Roots间没有任何引用链相连，证明此对象是不可能再被使用的。
            GC Roots对象包括：
            1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
            2. 在方法区中类静态属性引用的对象：例如ava类的引用类型静态变量。
            3. 在方法区中常量引用的对象：例如字符串常量池的引用
            4. 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
            5. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器；
            6. 所有被同步锁（synchronized关键字）持有的对象。
            7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
        3. 引用
  
           强引用：只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
           软引用：用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，
                    如果这次回收还没有足够的内存，才会抛出内存溢出异常。
           弱引用：描述那些非必须对象，当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象
           虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，为一个对象设置虚引用关联的唯一目的是为了能在这个对象被收集器回收时收                    到一个系统通知。
        4. 标记
            判断一个对象真正死亡，至少要经历两次标记过程：
                1. 可达性分析后，没有发现有与GC Roots相连接的引用链，那它将会被第一次标记；
                2. 判断对象否有必要执行finalize()方法，如果对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”
                   如果被判定为有必要，对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行其finalize()方法。
                   任何一个对象的finalize()方法都只会被系统自动调用一次 
        5. 回收方法区
            方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型
            判定一个类型是否属于不再使用的类的条件：
                1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
                2. 加载该类的类加载器已经被回收
                3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
 2. 垃圾回收算法
    
    1. 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集；
    2. 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集，目前只有CMS收集器会有单独收集老年代的行为；
    3. 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为；
    4. 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。
  
  1. 回收算法
    
        1. 标记-清除算法：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以标记存活的对象，统一回收所有未被标记的对象。
            缺点：
                1. 执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，导致执行效率随对象数量增长而降低；
                2. 内存空间的碎片化问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多会导致分配较大对象时无法找到足够的内存空间而提前触发另一次垃圾收集动作；
        2. 标记-复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉
            缺点：
                1. 如果内存中多数对象都是存活的，将会产生大量的内存空间复制的开销；
                2. 将可用空间分为了大小相等的两块，空间浪费
            优化：
                1. IBM公司研究表明，新生代中的对象有98%熬不过第一轮收集，并不需要按照1∶1的比例来划分新生代的内存空间；
                2. 把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。8:1:1
                3. 当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保
        3. 标记-整理算法(老年代)：首先标记出所有需要回收的对象，在标记完成后，让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。
            缺点：
                1. 如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有对象引用将会是一种极为负重的操作，需要暂定用户应用程序；
 2. hotspot的算法细节
    
        1. 根节点枚举：必须暂停用户线程，
            1. 因为根节点的枚举必须在一个能保障一致性的快照中才得以进行；
            2. 在HotSpot中，使用一组称为OopMap的数据结构存放对象引用
        2. 安全点：用户线程执行到达安全点后才能够暂停，抢先式中断、主动式中断
            1.主动式中断：当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最
                近的安全点上主动中断挂起；
            2. 抢先式中断：在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上
        3. 安全区域：当用户线程处于Sleep状态或者Blocked状态，无法响应虚拟机的中断请求，无法走到安全点去中断挂起，需要引入安全区域解决。
            1. 安全区域：能够确保在某一段代码片段之中，引用关系不会发生变化，在这个区域中任意地方开始垃圾收集都是安全的
            2. 离开安全区域时，需要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了则继续执行，否则它就必须一直等待，直到收到可以
                离开安全区域的信号为止。
        4. 记忆集与卡表  
            1. 记忆集：用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，实现方式：
                1. 字长精度：每个记录精确到一个机器字长，包含跨代指针
                2. 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。
                3. 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。
            2. 卡表：字节数组组成，CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page)
    
 ![image](https://user-images.githubusercontent.com/41152743/147333153-24f0cf71-cee2-46f4-bc58-0ffd45cdc1fb.png)
    
        5. 写屏障：维护卡表状态
            1. 写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形（Around）通知；
            2. 写屏障，每次只要对引用进行更新，会产生额外的开销，在高并发情形下，还存在伪共享问题
        6. 并发的可达性分析
            1. 三色标记
                1. 白色：表示对象尚未被垃圾收集器访问过，刚开始阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
                2. 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍，黑色对象不可能直接（不                    经过灰色对象）指向某个白色对象。
                3. 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。
              误标：当且仅当满足以下两个条件时，黑色的对象被标记为白色
                1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
                2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。
              解决方案：
                1. 增量更新：破坏第一个条件，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象，需要重新扫描。CMS是基于增量更新的
                2. 原始快照：破坏第二个条件，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。G1是使用原始快照
    3. 经典垃圾收集器
    
 ![image](https://user-images.githubusercontent.com/41152743/147337201-c2044695-2ebe-4872-b595-a5a2382db138.png)
    
        1. Serial收集器：新生代收集器，单线程，客户端模式下的虚拟机
           Serial Old收集器：Serial收集器的老年代版本，单线程，使用标记-整理算法，客户端模式下的HotSpot虚拟机
            如果在服务端模式下用途：
                1. JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用；
                2. 作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。
    
![image](https://user-images.githubusercontent.com/41152743/147337305-5f17e0e1-2e0e-46fa-a1b8-23cd7066cc78.png)
    
        2. ParNew收集器：新生代收集器，服务端模式下的HotSpot虚拟机，Serial收集器的多线程并行版本，除了Serial收集器外，目前只有它能与CMS收集器配合。
            JDK 9以后，取消了-XX：+UseParNewGC参数，ParNew和CMS从此只能互相搭配使用，可以说ParNew合并入CMS
![image](https://user-images.githubusercontent.com/41152743/147619691-9940a006-194d-4860-87f5-9939225b53c5.png)
        
        3. Parallel Scavenge收集器：新生代收集器，基于标记-复制算法，并行收集的多线程收集器
            目标：达到一个可控制的吞吐量，吞吐量=(运行用户代码时间)/(运行用户代码时间+运行垃圾收集时间)；
            -XX：MaxGCPauseMillis：尽力保证内存回收花费的时间不超过用户设定值，是以牺牲吞吐量和新生代空间为代价换取的。
            -XX：GCTimeRatio：垃圾收集时间占总时间的比率，相当于吞吐量的倒数。
            -XX：+UseAdaptiveSizePolicy，激活该参数，就不需要新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold)，                   根据当前系统的运行情况动态调整这些参数以提供最合适的停顿时间和最大的吞吐量
            
            Parallel Old收集器：Parallel Scavenge收集器的老年代版本，多线程并发收集，基于标记整理算法，JDK 1.6提供  
![image](https://user-images.githubusercontent.com/41152743/147621440-8c279a14-b953-49cb-9d72-4f765b062f30.png)
        
        4. CMS收集器：获取最短回收停顿时间为目标的收集器，基于标记-清除算法，并发收集，低停顿，适用于在互联网网站或者基于浏览器的B/S系统的服务端上，四个步骤：
    
 ![image](https://user-images.githubusercontent.com/41152743/147623928-baccff2a-8fbb-4205-9b40-aa1f1d135eaf.png)

            1. 初始标记：需要“Stop The World”，仅仅只是标记一下GCRoots能直接关联到的对象，速度很快
            2. 并发标记：不需要“Stop The World”，从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长
            3. 重新标记：需要“Stop The World”，为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记稍长，并发标记短
            4. 并发清除：清理删除掉标记阶段判断的已经死亡的对象，并发进行
            总结：
                1. 对处理器资源非常敏感，默认回收线程：（处理器核心数量+3）/4，当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大
                2.  无法处理“浮动垃圾”（Floating Garbage），有可能出现“Concurrent ModeFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生。
                    垃圾收集阶段用户线程仍需进行，需预留一部分内存空间供并发收集的程序使用。JDK 5 老年代使用了68%的空间后就会被激活，JDK 6 ，92%，
                    -XX：CMSInitiatingOccu-pancyFraction，设置CMS的触发百分比
                    如果CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”，此时冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，
                3. “标记-清除”算法实现，收集结束时可能会有大量空间碎片产生，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前                       对象，而不得不提前触发一次Full GC的情况。
          
        5. Garbage First收集器：面向服务端应用的垃圾收集器，JDK 9 ，成为服务端模式下的默认垃圾收集器
            1. 把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region，扮演新生代的Eden空间、Survivor空间，或者老年代空间
                还有一类特殊的Humongous区域，专门用来存储大对象，G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。
                -XX：G1HeapRegionSize，设定region大小，取值范围为1MB～32MB，且应为2的N次幂
            2. 让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），
                优先处理回收价值收益最大的那些Region。
            3. Region里面的跨Region引用对象，每个Region都维护有自己的记忆集，记录别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内，占用更高的内存负担，
                至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。
            4. 并发标记阶段，解决误标记问题，通过原始快照的算法实现。G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，
                把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上(G1默认他们是存活的)；
                如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行
            5. 运作过程：
                
                   1. 初始标记：需要停顿用户线程，但耗时很短，仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region 中分配新对象；
                   2. 并发标记：不需要停顿用户线程，耗时较长，从GC Root开始对堆中对象进行可达性分析，对象图扫描完成后，需要重新处理SATB记录下的在并发时有引用变动的对象。
                   3. 最终标记：需要停顿用户线程，处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
                   4. 筛选回收：需要停顿用户线程，负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，
                                把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间
![image](https://user-images.githubusercontent.com/41152743/147624951-c38e87fa-3678-4822-97ef-a7a721c0cdd9.png)

