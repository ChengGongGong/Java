# Java
## 1. java内存区域
### 1.运行时数据区域
1. 程序计数器：线程私有，为了线程切换后能恢复到正确的执行位置
2. java虚拟机栈：线程私有，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息
3. 本地方法栈：为虚拟机使用到的本地（Native）方法服务。
4. java堆：各个线程共享的内存区域，存放对象实例，几乎所有的对象实例以及数组都应当在堆上分配。
5. 方法区：各个线程共享的内存区域，存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
6. 直接内存：本机直接内存的分配不会受到Java堆大小的限制
7. 元空间：JDK1.8之前，hotspot虚拟机采用永久代的方法实现方法区，容易遇到内存溢出的问题。JDK 1.8之后废弃永久代，使用本地内存来存储类元数据信息
8. 常量池：字符串常量池、class常量池、运行时常量池 
### 2.对象探索
1. 对象的创建：

    类加载检查->分配内存(指针碰撞、空闲列表)：分配内存动作的线程安全问题-->内存空间初始化为零值--->设置对象头信息-->new关键字执行<init>()方法，按照程序员的意愿对对象进行初始化
2. 对象的内存布局
  
        对象头（Header）：存储对象自身的运行时数据、类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例、如果是数组的话还需记录数组长度；
  
        实例数据（Instance Data）：
  
        对齐填充（Padding）：不是必然存在的，HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，起着占位符的作用
3. 对象的访问定位：使用句柄访问、直接指针访问
### 3. 垃圾收集器
1. 判断对象已死？
  
        1. 引用计数法：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的
            但是很难解决对象之间相互循环引用的问题。

        2. 可达性分析算法：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），
           如果某个对象到GC Roots间没有任何引用链相连，证明此对象是不可能再被使用的。
            GC Roots对象包括：
            1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
            2. 在方法区中类静态属性引用的对象：例如ava类的引用类型静态变量。
            3. 在方法区中常量引用的对象：例如字符串常量池的引用
            4. 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
            5. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器；
            6. 所有被同步锁（synchronized关键字）持有的对象。
            7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
        3. 引用
  
           强引用：只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
           软引用：用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，
                    如果这次回收还没有足够的内存，才会抛出内存溢出异常。
           弱引用：描述那些非必须对象，当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象
           虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，为一个对象设置虚引用关联的唯一目的是为了能在这个对象被收集器回收时收                    到一个系统通知。
        4. 标记
            判断一个对象真正死亡，至少要经历两次标记过程：
                1. 可达性分析后，没有发现有与GC Roots相连接的引用链，那它将会被第一次标记；
                2. 判断对象否有必要执行finalize()方法，如果对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”
                   如果被判定为有必要，对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行其finalize()方法。
                   任何一个对象的finalize()方法都只会被系统自动调用一次 
        5. 回收方法区
            方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型
            判定一个类型是否属于不再使用的类的条件：
                1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
                2. 加载该类的类加载器已经被回收
                3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
  
  
  
  
  
  
